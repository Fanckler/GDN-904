'use strict';
const _ = require('lodash');
const glob = require('glob');
const fs = require('fs');
const fse = require('fs-extra');
const pathUtils = require('path');
const webpack = require('webpack');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const ManifestPlugin = require('webpack-manifest-plugin');
const ExtractCssPlugin = require('extract-text-webpack-plugin');
const ReplaceResource = require('@alldigitalads/nodejs_modules-replace-resource-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const WebpackTouch = require('./plugins/touch-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const DeleteUnusedEntriesLSPlugin = require('./plugins/delete-unused-entries-js-plugin');
const QAManifestPlugin = require('./plugins/qa-manifest-plugin');
const SymfonyManifestPlugin = require('./plugins/symfony-manifest-plugin');
const SendFilesPlugin = require('./plugins/send-files-plugin');
const autoprefixer = require('autoprefixer');

var rootPath = process.cwd();
var devPath;

class TwigCompilator{
    constructor(options){
        this.options = _.extend({
            makeSymfonyManifest: false,
            domain: process.env.CUSTOM_DOMAIN || 'http://localhost:8080',
            output: {
                path: rootPath + '/public',
                publicPath: '/',
                filename: '[name].[hash:8].js'
            },
            sourcePath: './src',
            cssPath: './src/css',
            imagesPath: './src/images',
            fontsPath: './src/fonts',
            jsPath: './src/js',
            videoPath: './src/video',
            soundsPath: './src/sounds',
            templatePath: './src/twig/templates',
            fixturesPath: './src/twig/fixtures',
            dynamicFixtures: [],
            renderList: {},
            cssFileName: '[name].[hash:8].css',
            routeRules: {},
            translateMessages: {},
            fixtures: {},
            provide: {},
            define: {},
            recompileDelay: 0,
            plugins: [],
            devServer: {
                contentBase: rootPath + '/public',
                publicPath: '/',
                port: 8080
            },
            vendorsFilePath: false,
            splitChunks: false,
            smExcludePaths: [],
            uploadMocks: [],
            uploadMocksUrl: null,
        }, options);
        this.options.define.outputPath = JSON.stringify(this.options.output.path.replace(rootPath+'/', ''));
        this.options.define.symfony_app = {
            locale: 'en'
        };
        this.options.noJsEntries = [];

        devPath = pathUtils.resolve(rootPath, this.options.sourcePath);
    }

    setDomain(domain){
        this.options.domain = domain;
        return this;
    }

    configServerProxy(config){
        let parser = require('querystring');
        this.options.devServer.before = (app) => {
            let urls = Object.keys(config.bypass);
            if(urls.length == 0){
                return;
            }

            app.all(
                urls.map(
                    (item) => {return item.replace(/\/$/, '') + '/*';}
                ),
                (req, res) => {
                    let str = '';
                    req.on('data', (data) => {
                        str += data;
                    });
                    req.on('end', () => {
                        req.body = parser.decode(str);

                        let URI = req.url.replace(/\?.*$/, '');
                        if(!config.bypass[URI]){
                            urls.some((item) =>{
                                let regexp = new RegExp('^'+item);
                                if(regexp.test(req.url)){
                                    URI = item;
                                    return true;
                                }

                                return false;
                            })
                        }

                        if(!config.bypass[URI]){
                            res.statusCode = 404;
                            res.setHeader('Content-Type', 'text/html');
                            res.write('<!DOCTYPE html><html><body>');
                            res.write(`<b>Warning!!!</b> Processor for ${req.url} not found`)
                            res.end('</body></html>');
                            return;
                        }

                        let settings = config.bypass[URI];
                        let methods = typeof settings.method == 'string'
                            ? [settings.method.toUpperCase()]
                            : settings.method.map((item) => {
                                return item.toUpperCase();
                            });

                        if(methods.indexOf(req.method.toUpperCase()) == -1){
                            res.statusCode = 405;
                            res.setHeader('Content-Type', 'text/html');
                            res.write('<!DOCTYPE html><html><body>');
                            res.write(`<b>Warning!!!</b> Request method not allowed`)
                            res.end('</body></html>');
                            return;
                        }

                        if(settings.path !== undefined) {
                            let fileUri = req.url.replace(new RegExp('^'+URI+'/?'), '');
                            let jsonFile = settings.path + '/' + fileUri.split('/').join('_') + '.json';
                            if (fs.existsSync(jsonFile)) {
                                res.json(fse.readJsonSync(jsonFile));
                            }
                            else {
                                res.statusCode = 404;
                                res.setHeader('Content-Type', 'text/html');
                                res.write('<!DOCTYPE html><html><body>');
                                res.write(`<b>Warning!!!</b> File <i>${jsonFile}</i> not found for request <i>${req.url}</i>`)
                                res.end('</body></html>');
                            }

                            return;
                        }

                        if (settings.script !== undefined && typeof settings.script == 'function') {
                            settings.script(req, res);
                        }
                        else if (settings.script !== undefined && typeof settings.script == 'string') {
                            let func = require(settings.script);
                            func(req, res);
                        }
                    });
                });
        };

        this.options.devServer.proxy = {};

        if(config.proxy){
            let proxySettings = config.proxy;
            let self = this;
            Object.keys(proxySettings).forEach((route) => {
                let params = proxySettings[route];
                if(!params.target || !/^http(s)?:\/\//.test(params.target)){
                    let uri = params.target || '';
                    params.target = self.options.domain + uri;
                }
            });

            this.options.devServer.proxy = config.proxy;
        }

        return this;
    }

    setOutput(output){
        if(typeof output !== 'object' || Array.isArray(output)){
            throw new Error('setOutput: Argument must be key/value object');
        }

        this.options.output = _.extend(this.options.output, output);
        return this;
    }

    setPath(name, path){
        if(typeof name === 'string' && typeof path === 'object'){
            throw new Error('setPath: Path must be a string');
        }
        else if(typeof name === 'object' && Array.isArray(name)){
            throw new Error('setPath: Argument 1 must be a string or key/value object');
        }

        if(typeof name === 'string'){
            if(this.options[name] === undefined || !/Path$/.test(name)){
                console.warn('\x1b[1;33m%s\x1b[0m', 'WARNING! setPath: Path name "'+name+'" is not allowed and will be ignored')
            }
            else{
                this.options[name] = path;
            }
        }
        else{
            path = name;
            Object.keys(path).forEach(function(name){
                if(this.options[name] === undefined || !/Path$/.test(name)){
                    console.warn('\x1b[1;33m%s\x1b[0m', 'WARNING! setPath: Path name "'+name+'" is not allowed and will be ignored')
                }
                else{
                    this.options[name] = path[name];
                }
            })
        }
    }

    setRenderList(list){
        if(Array.isArray(list)){
            throw new Error('setRenderList: Argument must be a key/value object or string');
        }

        this.options.renderList = list;
        return this;
    }

    setTranslateMessages(messages){
        if(Array.isArray(messages)){
            throw new Error('setRenderList: Argument must be a key/value object or string');
        }

        this.options.translateMessages = messages;
        return this;
    }

    setRouteRules(rules){
        if(Array.isArray(rules)){
            throw new Error('setRenderList: Argument must be a key/value object or string');
        }

        this.options.routeRules = rules;
        return this;
    }

    setFixtures(fixtures){
        if(Array.isArray(fixtures)){
            throw new Error('setFixtures: Argument must be string or key/value object');
        }

        this.options.fixtures = fixtures;
        return this;
    }

    setRecompileDelay(delay){
        this.options.recompileDelay = delay;
        return this;
    }

    setDynamicFixtures(data){
        if(Array.isArray(data)){
            throw new Error('setDynamicFixtures: Argument must be string or key/value object');
        }

        var obj = {};
        if(typeof data == 'string'){
            obj = require(pathUtils.resolve(rootPath, data));
        }
        else{
            obj = data;
        }

        var self = this;
        Object.keys(obj).forEach(function(from){
            self.options.dynamicFixtures.push({
                from: from,
                to: obj[from]
            });
        });

        return this;
    }

    setTemplatePath(path){
        this.options.templatePath = path;
        return this;
    }

    createSymfonyManifest(value, exclude){
        this.options.makeSymfonyManifest = value;
        exclude = exclude || [];
        if(exclude.length) {
            this.options.smExcludePaths = exclude
        }
        return this;
    }

    addProvide(provide){
        if(typeof provide !== "object" || Array.isArray(provide)){
            throw new Error('addProvide: Argument must be key/value object');
        }

        this.options.provide = _.extend(this.options.provide, provide);
        return this;
    }

    addDefine(define){
        if(typeof define !== 'object' || Array.isArray(define)){
            throw new Error('addDefine: Argument must be key/value object');
        }

        this.options.define = _.extend(this.options.define, define);
        return this;
    }

    addPlugin(plugins) {
        if(Array.isArray(plugins)){
            this.options.plugins = [...this.options.plugins, ...plugins];
        }
        else{
            this.options.plugins.push(plugins);
        }
        return this;
    }

    addProcessVendors(vendorsFilePath) {
        if(typeof vendorsFilePath !== 'string' || vendorsFilePath.length <= 0){
            throw new Error('addProcessVendors: Argument must be a non empty string');
        }

        this.options.vendorsFilePath = vendorsFilePath;
        fse.ensureFileSync(pathUtils.resolve(this.options.sourcePath+'/'+vendorsFilePath+'.js'));

        return this;
    }

    needSplitChunks(splitChunk) {
        this.options.splitChunks = !!splitChunk;
        return this;
    }

    configUploadMocks(url, files){
        this.options.uploadMocks = files;
        this.options.uploadMocksUrl = url;
        return this;
    }

    configServer(options = {}){
        if(options.proxy){
            delete options['proxy'];
            console.warn('Use method configServerProxy() for proxy configuration');
        }
        _.merge(this.options.devServer, options);
        return this;
    }

    getWebpackConfig(){
        return {
            entry: _makeEntries(this.options),
            output: this.options.output,
            plugins: _makePlugins(this.options),
            optimization: _makeOptimization(this.options),
            module: {
                rules: [
                    {
                        test: /\.js$/,
                        use: {
                            loader: 'babel-loader',
                            options: {
                                presets: ['@babel/preset-env']
                            }
                        }
                    },
                    {
                        test: /\.css$/,
                        use: ExtractCssPlugin.extract({
                            fallback: "style-loader",
                            use: [{
                                loader: "css-loader",
                            }, {
                                loader: 'postcss-loader',
                                options: {
                                    plugins: [
                                        autoprefixer
                                    ]
                                }
                            }]
                        })
                    },
                    {
                        test: /\.s[ac]ss$/,
                        use: ExtractCssPlugin.extract({
                            fallback: 'style-loader',
                            use: [{
                                loader: "css-loader",
                            },{
                                loader: 'postcss-loader',
                                options: {
                                    plugins: [
                                        autoprefixer
                                    ]
                                }
                            },
                                'sass-loader'
                            ]
                        })
                    },
                    {
                        test: /\.(ttf|woff|woff2|eot)$/,
                        use: [{
                            loader: 'file-loader',
                            options: {
                                name: _getRelativeFilename(rootPath, this.options.fontsPath+'/[name].[hash:8].[ext]')
                            }
                        }]
                    },
                    {
                        test: /\.(jpg|jpeg|gif|png|svg|ico)$/,
                        use: [{
                            loader: 'file-loader',
                            options: {
                                name: _getRelativeFilename(rootPath, this.options.imagesPath+'/[name].[hash:8].[ext]')
                            }
                        }]
                    },
                    {
                        test: /\.(mp4|webm|ogv)$/,
                        use: [{
                            loader: 'file-loader',
                            options: {
                                name: _getRelativeFilename(rootPath, this.options.videoPath+'/[name].[hash:8].[ext]')
                            }
                        }]
                    },
                    {
                        test: /\.(mp3|wav|aiff|ogg|oga|mogg|wma)$/,
                        use: [{
                            loader: 'file-loader',
                            options: {
                                name: _getRelativeFilename(rootPath, this.options.soundsPath+'/[name].[hash:8].[ext]')
                            }
                        }]
                    },
                    {
                        test: /\.twig$/,
                        use: [{
                            loader: '@alldigitalads/nodejs_modules-twig-extended-loader',
                            options: {
                                domain: this.options.domain,
                                templateRoot: pathUtils.resolve(rootPath, this.options.templatePath),
                                testDataRoot: pathUtils.resolve(rootPath, this.options.fixturesPath),
                                fixtures: typeof this.options.fixtures == 'object'
                                    ? this.options.fixtures
                                    : require(pathUtils.resolve(rootPath, this.options.fixtures)),
                                routerRules: typeof this.options.routeRules == 'object'
                                    ? this.options.routeRules
                                    : pathUtils.resolve(rootPath, this.options.routeRules),
                                transMessages: typeof this.options.translateMessages == 'object'
                                    ? this.options.translateMessages
                                    : pathUtils.resolve(rootPath, this.options.translateMessages)
                            }
                        }]
                    }
                ]
            },
            devServer: this.options.devServer
        }
    }
}

function _makeEntries(options){
    var entries = {};
    var noJsEntries = [];
    var env = process.env.NODE_ENV !== undefined ? process.env.NODE_ENV : 'development';

    //Assets => Entry
    var templates = glob.sync(options.templatePath+'/**/*.twig', {nodir: true});
    var assets = [];
    templates.forEach(function(template){
        var source = fs.readFileSync(template, {encoding: 'utf8'});
        var matches = source.match(/asset\(('|")([^'"]+)\1\)/g);
        if(matches !== null){
            matches.forEach(function(match){
                assets.push(match.replace(/asset\(('|")([^'"]+)\1\)/, '$2'));
            });
        }
    });

    assets.forEach(function(chunk){
        if(/\.(s[ac]ss|js|css)$/.test(chunk)){
            entries[chunk.replace(/\.(s[ac]ss|css|js)$/, '')] = options.sourcePath+'/'+chunk;
        }
        else{
            entries[chunk] = options.sourcePath+'/'+chunk;
        }

        if(!/\.js$/.test(chunk) && options.noJsEntries.indexOf(chunk) == -1){
            options.noJsEntries.push(chunk.replace(/\.(s[ac]ss|css)$/, ''));
        }
    });

    return entries;
}

function _makePlugins(options){
    var plugins = [
        new CleanWebpackPlugin(options.output.path, {verbose: true, allowExternal: true}),
        new DeleteUnusedEntriesLSPlugin(options.noJsEntries),
        new ManifestPlugin(),
        new webpack.ProvidePlugin(options.provide),
        new webpack.DefinePlugin(options.define),
        new ExtractCssPlugin({
            filename: options.cssFileName,
        }),
        new QAManifestPlugin({
            pageList: pathUtils.resolve(rootPath, options.renderList)
        })
    ];

    var renderList = typeof options.renderList == 'object'
        ? options.renderList
        : require(pathUtils.resolve(rootPath, options.renderList));

    if(options.makeSymfonyManifest !== false){
        plugins.push(new SymfonyManifestPlugin({
            sourcePath: options.sourcePath,
            templatesPath: options.templatePath,
            translatePath: typeof options.translateMessages =='string' ? options.translateMessages : '',
            renderList: Object.keys(renderList),
            globalVendor: options.vendorsFilePath,
            splitChunks: options.splitChunks,
            exclude: options.smExcludePaths
        }));
    }

    var templates = renderList;
    var touch_files = [];

    Object.keys(templates).forEach(function(template){
        plugins.push(new HtmlWebpackPlugin({
            chunks: [],
            filename: template.replace(/\.twig$/, ''),
            template: options.templatePath+'/'+template
        }));

        touch_files.push(pathUtils.resolve(rootPath, options.templatePath+'/'+template));

    });

    plugins.push(new ReplaceResource());

    if(options.uploadMocksUrl && options.uploadMocks.length) {
        plugins.push(new SendFilesPlugin(options.uploadMocksUrl, options.uploadMocks));
    }

    if(process.env.NODE_ENV == 'development' && options.dynamicFixtures.length > 0){
        plugins.push(new CopyWebpackPlugin(options.dynamicFixtures));
    }

    if(/webpack(\.js)?$/.test(process.argv[1]) && (process.argv.indexOf('--watch') == -1 && process.argv.indexOf('-w') == -1 )){
        return [...plugins, ...options.plugins];
    }

    var watchFor = [
        pathUtils.resolve(rootPath, options.sourcePath)
    ];

    if(typeof options.renderList == 'string'){
        watchFor.push(pathUtils.resolve(rootPath, options.renderList));
    }

    if(typeof options.fixturesPath == 'string'){
        watchFor.push(pathUtils.resolve(rootPath, options.fixturesPath));
    }

    if(typeof options.routeRules == 'string'){
        watchFor.push(pathUtils.resolve(rootPath, options.routeRules));
    }

    if(typeof options.translateMessages == 'string'){
        watchFor.push(pathUtils.resolve(rootPath, options.translateMessages));
    }

    if(options.recompileDelay > 0) {
        plugins.push(new WebpackTouch({
            watchFor: watchFor,
            files: touch_files,
            delay: options.recompileDelay
        }));
    }

    return [...plugins, ...options.plugins];
}

function _makeOptimization(options){
    var optimization = {};

    if (!!options.vendorsFilePath && options.vendorsFilePath.length > 0) {
        optimization = {
            splitChunks: {
                cacheGroups: {
                    vendor: {
                        chunks: "all",
                        name: options.vendorsFilePath,
                        minChunks: 2,
                        reuseExistingChunk: true,
                    }
                }
            },
            occurrenceOrder: true
        };
    }

    return optimization;
}

function _getRelativeFilename(root, filename){
    var fullPath = pathUtils.resolve(root, filename);
    return fullPath.replace(devPath+pathUtils.sep, '').replace(/\\/g, '/');
}

module.exports = TwigCompilator;