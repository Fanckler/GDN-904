const fs = require('fs');
const path = require('path');
const glob = require('glob');
const crypto = require('crypto');

function addHook(compiler, pluginName, hookName, hook) {
    if ('hooks' in compiler) {
        compiler.hooks[hookName].tap(pluginName, hook);
    } else {
        compiler.plugin(hookName, hook);
    }
}

function WebpackTouch(options) {
    this.options = options || {};
    this.cache = {};
    if (!this.options.files) {
        throw new Error('Require files option');
    }
    if(typeof this.options.files === 'string'){
        this.options.files = [this.options.files];
    }

    if(this.options.watchFor){
        if(typeof this.options.watchFor === 'string'){
            this.options.watchFor = [this.options.watchFor];
        }

        var watch_files = [];
        this.options.watchFor.forEach(function(watchPath){
            if(!fs.existsSync(watchPath)){
                console.log('\x1b[1;33m%s\x1b[0m', 'No such file or directory "'+watchPath+'"');
                return;
            }
            if(fs.statSync(watchPath).isDirectory()){
                glob.sync(watchPath+'/**', {nodir: true}).forEach(function(file){
                    watch_files.push(file);
                })
            }
            else if(fs.statSync(watchPath).isFile()){
                watch_files.push(watchPath);
            }
        });

        var cache = this.cache;
        watch_files.forEach(function(file){
            var hash = crypto.createHash('sha1');
            hash.setEncoding('hex');
            var source = fs.readFileSync(file);
            hash.write(source);
            hash.end();
            cache[file] = hash.read();
        });

        watch_files = watch_files.filter(function(elem, pos) {
            return watch_files.indexOf(elem) == pos;
        })
    }
}

WebpackTouch.prototype.apply = function (compiler) {
    options = this.options;
    var cache = this.cache;

    var timeId = null;
    addHook(compiler, 'WebpackTouch', 'done', function (stats) {
        if (options.ignoreOnError && stats.hasErrors()) {
            console.log('Not touch on error');
            return;
        }
        if (options.delay) {
            timeId = setInterval(watch, options.delay);
        } else {
            touch();
        }
    });

    function watch(){
        if(Object.keys(cache).length == 0) {
            touch();
        }

        var needTouch = false;
        Object.keys(cache).forEach(function(file){
            var hash = crypto.createHash('sha1');
            hash.setEncoding('hex');
            var source = fs.readFileSync(file);
            hash.write(source);
            hash.end();
            var new_hash = hash.read();
            if(new_hash != cache[file]){
                cache[file] = new_hash;
                needTouch = true;
            }
        });

        if(needTouch){
            touch();
        }
    }

    function touch() {
        try {
            const now = new Date();
            options.files.forEach(function(filename){
                if (fs.existsSync(filename)) {
                    fs.utimesSync(filename, now, now);
                } else {
                    fs.writeFileSync(filename, '');
                }
            });

        } catch (e) {
            console.error(e)
        }

        if(typeof timeId == 'object') {
            clearInterval(timeId);
        }
    }
};

module.exports = WebpackTouch;